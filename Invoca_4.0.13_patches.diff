diff --git a/activerecord/lib/active_record/connection_adapters/abstract/schema_definitions.rb b/activerecord/lib/active_record/connection_adapters/abstract/schema_definitions.rb
index 8bf020a..a2e3168 100644
--- a/activerecord/lib/active_record/connection_adapters/abstract/schema_definitions.rb
+++ b/activerecord/lib/active_record/connection_adapters/abstract/schema_definitions.rb
@@ -226,7 +226,8 @@ def remove_column(name)
         @columns_hash.delete name.to_s
       end
 
-      [:string, :text, :integer, :float, :decimal, :datetime, :timestamp, :time, :date, :binary, :boolean].each do |column_type|
+      # Invoca patch - add 'varbinary'
+      [:string, :text, :integer, :float, :decimal, :datetime, :timestamp, :time, :date, :binary, :boolean, :varbinary].each do |column_type|
         define_method column_type do |*args|
           options = args.extract_options!
           column_names = args
diff --git a/activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb b/activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb
index 246d2b6..f146c85 100644
--- a/activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb
+++ b/activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb
@@ -695,7 +695,10 @@ def type_to_sql(type, limit = nil, precision = nil, scale = nil) #:nodoc:
       end
 
       def add_column_options!(sql, options) #:nodoc:
-        sql << " DEFAULT #{quote(options[:default], options[:column])}" if options_include_default?(options)
+        # Invoca Patch - MySQL doesn't allow DEFAULT NULL with NOT NULL -- it's implied when DEFAULT omitted
+        if options_include_default?(options) && !options[:default].nil?
+          sql << " DEFAULT #{quote(options[:default], options[:column])}"
+        end
         # must explicitly check for :null to allow change_column to work on migrations
         if options[:null] == false
           sql << " NOT NULL"
@@ -772,7 +775,8 @@ def quoted_columns_for_index(column_names, options = {})
         end
 
         def options_include_default?(options)
-          options.include?(:default) && !(options[:null] == false && options[:default].nil?)
+          # Invoca Patch - allow DEFAULT NULL statements
+          options.include?(:default) # && !(options[:null] == false && options[:default].nil?)
         end
 
         def add_index_options(table_name, column_name, options = {})
@@ -815,8 +819,11 @@ def add_index_options(table_name, column_name, options = {})
           if index_name.length > max_index_length
             raise ArgumentError, "Index name '#{index_name}' on table '#{table_name}' is too long; the limit is #{max_index_length} characters"
           end
-          if index_name_exists?(table_name, index_name, false)
-            raise ArgumentError, "Index name '#{index_name}' on table '#{table_name}' already exists"
+          # Invoca Patch
+          unless (options.key?(:check_for_existence) || options[:check_for_existence])
+            if index_name_exists?(table_name, index_name, false)
+              raise ArgumentError, "Index name '#{index_name}' on table '#{table_name}' already exists"
+            end
           end
           index_columns = quoted_columns_for_index(column_names, options).join(", ")
 
diff --git a/activerecord/lib/active_record/connection_adapters/abstract_mysql_adapter.rb b/activerecord/lib/active_record/connection_adapters/abstract_mysql_adapter.rb
index 8c0b118..7cfa4ad 100755
--- a/activerecord/lib/active_record/connection_adapters/abstract_mysql_adapter.rb
+++ b/activerecord/lib/active_record/connection_adapters/abstract_mysql_adapter.rb
@@ -91,7 +91,7 @@ def extract_limit(sql_type)
             when /medium/i
               16777215
             when /long/i
-              2147483647 # mysql only allows 2^31-1, not 2^32-1, somewhat inconsistently with the tiny/medium/normal cases
+              4294967295 # Invoca Patch - double the size for long
             else
               super # we could return 65535 here, but we leave it undecorated by default
             end
@@ -137,18 +137,20 @@ def missing_default_forged_as_empty_string?(default)
       QUOTED_TRUE, QUOTED_FALSE = '1', '0'
 
       NATIVE_DATABASE_TYPES = {
-        :primary_key => "int(11) DEFAULT NULL auto_increment PRIMARY KEY",
-        :string      => { :name => "varchar", :limit => 255 },
-        :text        => { :name => "text" },
-        :integer     => { :name => "int", :limit => 4 },
-        :float       => { :name => "float" },
-        :decimal     => { :name => "decimal" },
-        :datetime    => { :name => "datetime" },
-        :timestamp   => { :name => "datetime" },
-        :time        => { :name => "time" },
-        :date        => { :name => "date" },
-        :binary      => { :name => "blob" },
-        :boolean     => { :name => "tinyint", :limit => 1 }
+        :primary_key              => "int auto_increment PRIMARY KEY",
+        :primary_key_no_increment => "int(11) PRIMARY KEY", # Invoca Patch
+        :string                   => { :name => "varchar", :limit => 255 },
+        :text                     => { :name => "text" },
+        :integer                  => { :name => "int", :limit => 4 },
+        :float                    => { :name => "float" },
+        :decimal                  => { :name => "decimal" },
+        :datetime                 => { :name => "datetime" },
+        :timestamp                => { :name => "datetime" },
+        :time                     => { :name => "time" },
+        :date                     => { :name => "date" },
+        :binary                   => { :name => "blob" },
+        :boolean                  => { :name => "tinyint", :limit => 1 },
+        :varbinary                => { :name => "varbinary", :limit=> 255 } # Invoca Patch
       }
 
       INDEX_TYPES  = [:fulltext, :spatial]
@@ -238,7 +240,8 @@ def error_number(exception) # :nodoc:
       # QUOTING ==================================================
 
       def quote(value, column = nil)
-        if value.kind_of?(String) && column && column.type == :binary && column.class.respond_to?(:string_to_binary)
+        # Invoca Patch - account for 'varbinary' type
+        if value.kind_of?(String) && column && [:binary, :varbinary].include?(column.type) && column.class.respond_to?(:string_to_binary)
           s = column.class.string_to_binary(value).unpack("H*")[0]
           "x'#{s}'"
         elsif value.kind_of?(BigDecimal)
diff --git a/activerecord/lib/active_record/connection_adapters/column.rb b/activerecord/lib/active_record/connection_adapters/column.rb
index 37620ee..e8063e5 100644
--- a/activerecord/lib/active_record/connection_adapters/column.rb
+++ b/activerecord/lib/active_record/connection_adapters/column.rb
@@ -64,6 +64,7 @@ def klass
         when :date                        then Date
         when :text, :string, :binary      then String
         when :boolean                     then Object
+        when :varbinary                   then String # Invoca Patch
         end
       end
 
@@ -128,6 +129,7 @@ def type_cast_code(var_name)
         when :hstore               then "#{klass}.string_to_hstore(#{var_name})"
         when :inet, :cidr          then "#{klass}.string_to_cidr(#{var_name})"
         when :json                 then "#{klass}.string_to_json(#{var_name})"
+        when :varbinary            then "#{klass}.binary_to_string(#{var_name})" # Invoca Patch
         else var_name
         end
       end
@@ -206,6 +208,8 @@ def value_to_integer(value)
           case value
           when TrueClass, FalseClass
             value ? 1 : 0
+          when ActiveSupport::OrderedHash # Invoca Patch
+            value.size
           else
             value.to_i rescue nil
           end
@@ -313,6 +317,8 @@ def simplified_type(field_type)
             :date
           when /clob/i, /text/i
             :text
+          when /varbinary/i # Invoca Patch
+            :varbinary
           when /blob/i, /binary/i
             :binary
           when /char/i, /string/i
diff --git a/activerecord/lib/active_record/railties/databases.rake b/activerecord/lib/active_record/railties/databases.rake
index 2042734..5ea5b55 100644
--- a/activerecord/lib/active_record/railties/databases.rake
+++ b/activerecord/lib/active_record/railties/databases.rake
@@ -282,16 +282,17 @@ db_namespace = namespace :db do
   end
 
   namespace :structure do
-    desc 'Dump the database structure to db/structure.sql. Specify another file with DB_STRUCTURE=db/my_structure.sql'
+    desc 'Dump the database structure to db/schema.sql. Specify another file with DB_STRUCTURE=db/my_structure.sql'
     task :dump => [:environment, :load_config] do
-      filename = ENV['DB_STRUCTURE'] || File.join(ActiveRecord::Tasks::DatabaseTasks.db_dir, "structure.sql")
+      # Invoca Patch - change 'structure.sql' to 'schema.sql'
+      filename = ENV['DB_STRUCTURE'] || File.join(ActiveRecord::Tasks::DatabaseTasks.db_dir, "schema.sql")
       current_config = ActiveRecord::Tasks::DatabaseTasks.current_config
       ActiveRecord::Tasks::DatabaseTasks.structure_dump(current_config, filename)
 
       if ActiveRecord::Base.connection.supports_migrations? &&
           ActiveRecord::SchemaMigration.table_exists?
         File.open(filename, "a") do |f|
-          f.puts ActiveRecord::Base.connection.dump_schema_information
+          f.puts ActiveRecord::Base.connection.dump_schema_information.gsub(/AUTO_INCREMENT=\d+ /,'') # Invoca Patch - need this for the custom data type patch in the abstract_mysql_adapter
         end
       end
       db_namespace['structure:dump'].reenable
@@ -299,9 +300,16 @@ db_namespace = namespace :db do
 
     # desc "Recreate the databases from the structure.sql file"
     task :load => [:environment, :load_config] do
-      filename = ENV['DB_STRUCTURE'] || File.join(ActiveRecord::Tasks::DatabaseTasks.db_dir, "structure.sql")
+      # Invoca Patch - change 'structure.sql' to 'schema.sql'
+      filename = ENV['DB_STRUCTURE'] || File.join(ActiveRecord::Tasks::DatabaseTasks.db_dir, "schema.sql")
       current_config = ActiveRecord::Tasks::DatabaseTasks.current_config
-      ActiveRecord::Tasks::DatabaseTasks.structure_load(current_config, filename)
+      # Invoca Patch - check that file exists and load file
+      File.exists?(filename) or abort %{#{filename} doesn't exist yet. Run "rake db:migrate" to create it then try again. If you do not intend to use a database, you should instead alter #{Rails.root}/config/boot.rb to limit the frameworks that will be loaded}
+      command = "mysql '-u#{config["username"]}' '-p#{config["password"]}' '#{config["database"]}' < '#{filename}'"
+      puts command if ENV['verbose'] != 'false'
+      system( command )
+      $?.success? or raise "#{task.name} failed executing `#{command}`"
+      # ActiveRecord::Tasks::DatabaseTasks.structure_load(current_config, filename)
     end
 
     task :load_if_sql => ['db:create', :environment] do
