diff --git a/activerecord/lib/active_record/connection_adapters/abstract/schema_definitions.rb b/activerecord/lib/active_record/connection_adapters/abstract/schema_definitions.rb
index 8bf020a..a2e3168 100644
--- a/activerecord/lib/active_record/connection_adapters/abstract/schema_definitions.rb
+++ b/activerecord/lib/active_record/connection_adapters/abstract/schema_definitions.rb
@@ -226,7 +226,8 @@ def remove_column(name)
         @columns_hash.delete name.to_s
       end
 
-      [:string, :text, :integer, :float, :decimal, :datetime, :timestamp, :time, :date, :binary, :boolean].each do |column_type|
+      # Invoca patch - add 'varbinary'
+      [:string, :text, :integer, :float, :decimal, :datetime, :timestamp, :time, :date, :binary, :boolean, :varbinary].each do |column_type|
         define_method column_type do |*args|
           options = args.extract_options!
           column_names = args
diff --git a/activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb b/activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb
index 246d2b6..f146c85 100644
--- a/activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb
+++ b/activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb
@@ -695,7 +695,10 @@ def type_to_sql(type, limit = nil, precision = nil, scale = nil) #:nodoc:
       end
 
       def add_column_options!(sql, options) #:nodoc:
-        sql << " DEFAULT #{quote(options[:default], options[:column])}" if options_include_default?(options)
+        # Invoca Patch - MySQL doesn't allow DEFAULT NULL with NOT NULL -- it's implied when DEFAULT omitted
+        if options_include_default?(options) && !options[:default].nil?
+          sql << " DEFAULT #{quote(options[:default], options[:column])}"
+        end
         # must explicitly check for :null to allow change_column to work on migrations
         if options[:null] == false
           sql << " NOT NULL"
@@ -772,7 +775,8 @@ def quoted_columns_for_index(column_names, options = {})
         end
 
         def options_include_default?(options)
-          options.include?(:default) && !(options[:null] == false && options[:default].nil?)
+          # Invoca Patch - allow DEFAULT NULL statements
+          options.include?(:default) # && !(options[:null] == false && options[:default].nil?)
         end
 
         def add_index_options(table_name, column_name, options = {})
@@ -815,8 +819,11 @@ def add_index_options(table_name, column_name, options = {})
           if index_name.length > max_index_length
             raise ArgumentError, "Index name '#{index_name}' on table '#{table_name}' is too long; the limit is #{max_index_length} characters"
           end
-          if index_name_exists?(table_name, index_name, false)
-            raise ArgumentError, "Index name '#{index_name}' on table '#{table_name}' already exists"
+          # Invoca Patch
+          unless (options.key?(:check_for_existence) || options[:check_for_existence])
+            if index_name_exists?(table_name, index_name, false)
+              raise ArgumentError, "Index name '#{index_name}' on table '#{table_name}' already exists"
+            end
           end
           index_columns = quoted_columns_for_index(column_names, options).join(", ")
 
diff --git a/activerecord/lib/active_record/connection_adapters/abstract_mysql_adapter.rb b/activerecord/lib/active_record/connection_adapters/abstract_mysql_adapter.rb
index 8c0b118..7cfa4ad 100755
--- a/activerecord/lib/active_record/connection_adapters/abstract_mysql_adapter.rb
+++ b/activerecord/lib/active_record/connection_adapters/abstract_mysql_adapter.rb
@@ -91,7 +91,7 @@ def extract_limit(sql_type)
             when /medium/i
               16777215
             when /long/i
-              2147483647 # mysql only allows 2^31-1, not 2^32-1, somewhat inconsistently with the tiny/medium/normal cases
+              4294967295 # Invoca Patch - double the size for long
             else
               super # we could return 65535 here, but we leave it undecorated by default
             end
@@ -137,18 +137,20 @@ def missing_default_forged_as_empty_string?(default)
       QUOTED_TRUE, QUOTED_FALSE = '1', '0'
 
       NATIVE_DATABASE_TYPES = {
-        :primary_key => "int(11) DEFAULT NULL auto_increment PRIMARY KEY",
-        :string      => { :name => "varchar", :limit => 255 },
-        :text        => { :name => "text" },
-        :integer     => { :name => "int", :limit => 4 },
-        :float       => { :name => "float" },
-        :decimal     => { :name => "decimal" },
-        :datetime    => { :name => "datetime" },
-        :timestamp   => { :name => "datetime" },
-        :time        => { :name => "time" },
-        :date        => { :name => "date" },
-        :binary      => { :name => "blob" },
-        :boolean     => { :name => "tinyint", :limit => 1 }
+        :primary_key              => "int auto_increment PRIMARY KEY",
+        :primary_key_no_increment => "int(11) PRIMARY KEY", # Invoca Patch
+        :string                   => { :name => "varchar", :limit => 255 },
+        :text                     => { :name => "text" },
+        :integer                  => { :name => "int", :limit => 4 },
+        :float                    => { :name => "float" },
+        :decimal                  => { :name => "decimal" },
+        :datetime                 => { :name => "datetime" },
+        :timestamp                => { :name => "datetime" },
+        :time                     => { :name => "time" },
+        :date                     => { :name => "date" },
+        :binary                   => { :name => "blob" },
+        :boolean                  => { :name => "tinyint", :limit => 1 },
+        :varbinary                => { :name => "varbinary", :limit=> 255 } # Invoca Patch
       }
 
       INDEX_TYPES  = [:fulltext, :spatial]
@@ -238,7 +240,8 @@ def error_number(exception) # :nodoc:
       # QUOTING ==================================================
 
       def quote(value, column = nil)
-        if value.kind_of?(String) && column && column.type == :binary && column.class.respond_to?(:string_to_binary)
+        # Invoca Patch - account for 'varbinary' type
+        if value.kind_of?(String) && column && [:binary, :varbinary].include?(column.type) && column.class.respond_to?(:string_to_binary)
           s = column.class.string_to_binary(value).unpack("H*")[0]
           "x'#{s}'"
         elsif value.kind_of?(BigDecimal)
diff --git a/activerecord/lib/active_record/connection_adapters/column.rb b/activerecord/lib/active_record/connection_adapters/column.rb
index 37620ee..e8063e5 100644
--- a/activerecord/lib/active_record/connection_adapters/column.rb
+++ b/activerecord/lib/active_record/connection_adapters/column.rb
@@ -64,6 +64,7 @@ def klass
         when :date                        then Date
         when :text, :string, :binary      then String
         when :boolean                     then Object
+        when :varbinary                   then String # Invoca Patch
         end
       end
 
@@ -128,6 +129,7 @@ def type_cast_code(var_name)
         when :hstore               then "#{klass}.string_to_hstore(#{var_name})"
         when :inet, :cidr          then "#{klass}.string_to_cidr(#{var_name})"
         when :json                 then "#{klass}.string_to_json(#{var_name})"
+        when :varbinary            then "#{klass}.binary_to_string(#{var_name})" # Invoca Patch
         else var_name
         end
       end
@@ -206,6 +208,8 @@ def value_to_integer(value)
           case value
           when TrueClass, FalseClass
             value ? 1 : 0
+          when ActiveSupport::OrderedHash # Invoca Patch
+            value.size
           else
             value.to_i rescue nil
           end
@@ -313,6 +317,8 @@ def simplified_type(field_type)
             :date
           when /clob/i, /text/i
             :text
+          when /varbinary/i # Invoca Patch
+            :varbinary
           when /blob/i, /binary/i
             :binary
           when /char/i, /string/i
diff --git a/activerecord/lib/active_record/fixtures.rb b/activerecord/lib/active_record/fixtures.rb
index 48240b4..710da05e 100644
--- a/activerecord/lib/active_record/fixtures.rb
+++ b/activerecord/lib/active_record/fixtures.rb
@@ -4,6 +4,7 @@
 require 'active_support/dependencies'
 require 'active_record/fixture_set/file'
 require 'active_record/errors'
+require 'shellwords' # Invoca Patch - there are many patches throughout this file, refer to a file diff for complete changes
 
 module ActiveRecord
   class FixtureClassNotFound < ActiveRecord::ActiveRecordError #:nodoc:
@@ -376,6 +377,7 @@ class FixtureSet
     #++
 
     MAX_ID = 2 ** 30 - 1
+    FIXTURE_REALMS = [:default, :sample_data]
 
     @@all_cached_fixtures = Hash.new { |h,k| h[k] = {} }
 
@@ -469,14 +471,16 @@ def self.create_fixtures(fixtures_directory, fixture_set_names, class_names = {}
 
           connection.transaction(:requires_new => true) do
             fixture_sets.each do |fs|
-              conn = fs.model_class.respond_to?(:connection) ? fs.model_class.connection : connection
-              table_rows = fs.table_rows
+              conn = fs.model_class.try(:connection) || connection
 
-              table_rows.keys.each do |table|
-                conn.delete "DELETE FROM #{conn.quote_table_name(table)}", 'Fixture Delete'
+              fs.table_rows.keys.each do |table_name|
+                conn.delete "DELETE FROM #{conn.quote_table_name(table_name)}", 'Fixture Delete'
               end
+            end
 
-              table_rows.each do |fixture_set_name, rows|
+            fixture_sets.each do |fs|
+              conn = fs.model_class.try(:connection) || connection
+              fs.table_rows.each do |fixture_set_name, rows|
                 rows.each do |row|
                   conn.insert_fixture(row, fixture_set_name)
                 end
@@ -840,6 +844,9 @@ def run_in_transaction?
         !self.class.uses_transaction?(method_name)
     end
 
+    @@active_fixture ||= :none
+    @@current_fixture_realm = :default
+
     def setup_fixtures
       return if ActiveRecord::Base.configurations.blank?
 
@@ -851,23 +858,49 @@ def setup_fixtures
       @fixture_connections = []
       @@already_loaded_fixtures ||= {}
 
-      # Load fixtures once and begin transaction.
+      if @@current_fixture_realm != fixture_realm
+        @@current_fixture_realm = fixture_realm
+        db_connect(@@current_fixture_realm)
+      end
+
+      if !@@already_loaded_fixtures[self.class].nil?
+        @loaded_fixtures = @@already_loaded_fixtures[self.class]
+      else
+        ActiveRecord::Fixtures.reset_cache
+        @loaded_fixtures ||= (marshal_hash || create_fixtures_from_yaml)
+        @@already_loaded_fixtures[self.class] = @loaded_fixtures
+      end
+
       if run_in_transaction?
-        if @@already_loaded_fixtures[self.class]
-          @loaded_fixtures = @@already_loaded_fixtures[self.class]
-        else
-          @loaded_fixtures = load_fixtures
-          @@already_loaded_fixtures[self.class] = @loaded_fixtures
-        end
         @fixture_connections = enlist_fixture_connections
         @fixture_connections.each do |connection|
           connection.begin_transaction joinable: false
         end
-      # Load fixtures for every test.
       else
-        ActiveRecord::FixtureSet.reset_cache
-        @@already_loaded_fixtures[self.class] = nil
-        @loaded_fixtures = load_fixtures
+        @@already_loaded_fixtures[self.class] = {}
+      end
+
+      def create_fixtures_from_yaml
+        fixtures = Fixtures.create_fixtures(fixture_path, fixture_table_names, fixture_class_names)
+        Hash[fixtures.map { |f| [f.name, f] }]
+      end
+
+      def marshal_hash
+        begin
+          marshal_hash = {}
+          marshal_load = Marshal.load(File.read("#{fixture_path}default.marshal"))
+          marshal_load.each do |yaml_file, (klass, fixtures)|
+            fixture_hash = {}
+            fixtures.each do |fixture_sym, id|
+              fixture_hash[fixture_sym] = Fixture.new({"id" => id}, klass._?.constantize)
+            end
+            marshal_hash[yaml_file] = fixture_hash
+          end
+          marshal_hash
+        rescue Exception => ex
+          puts "Error loading Marshal file #{fixture_path}default.marshal: #{ex}"
+          nil
+        end
       end
 
       # Instantiate fixtures for every test if requested.
@@ -894,11 +927,45 @@ def enlist_fixture_connections
       ActiveRecord::Base.connection_handler.connection_pool_list.map(&:connection)
     end
 
-    private
-      def load_fixtures
-        fixtures = ActiveRecord::FixtureSet.create_fixtures(fixture_path, fixture_table_names, fixture_class_names)
-        Hash[fixtures.map { |f| [f.name, f] }]
+    def load_fixtures
+      Fixtures::FIXTURE_REALMS.each do |fixture_name|
+        db_connect(fixture_name)
+
+        dump_file_name = "#{fixture_path}/#{fixture_name}.sql"
+        File.exists?(dump_file_name) or raise "load_fixtures: Could not find #{dump_file_name}"
+        load_mysql_dump(dump_file_name)
       end
+    end
+
+    private
+
+    def db_connect(fixture_realm_sym)
+      current_connection_handler = ActiveRecord::Base.connection_handler
+      current_database_spec = current_connection_handler.retrieve_connection_pool(ActiveRecord::Base).spec
+      new_connection_handler = ActiveRecord::ConnectionAdapters::ConnectionHandler.new
+      ActiveRecord::Base.connection_handler = new_connection_handler
+      new_database_name = ActiveRecord::Base.configurations["test#{"_" + fixture_realm_sym.to_s if fixture_realm_sym != :default}"]['database']
+      new_database_config = current_database_spec.config.merge(:database => new_database_name)
+      new_database_spec = current_database_spec.class.new(new_database_config, current_database_spec.adapter_method)
+      ActiveRecord::Base.establish_connection(new_database_spec.config)
+      ActiveRecord::Base.connection
+    end
+
+    # Possible alternative to the above method
+    # def db_connect(fixture_realm_sym)
+    #   ActiveRecord::Base.establish_connection("test#{'_sample_data' unless fixture_sym == :default}")
+    # end
+
+    def load_mysql_dump dump_filename
+      raise "Cannot be used in production!" if Rails.env == 'production'
+      config = ActiveRecord::Base.connection.config
+      dump_cmd = "mysql --user=#{Shellwords.shellescape(config[:username])} --password=#{Shellwords.shellescape(config[:password])} #{Shellwords.shellescape(config[:database])} < #{Shellwords.shellescape(dump_filename)}"
+      system(dump_cmd) or raise("Loading mysql dump failed: #{dump_cmd.inspect} resulted in an error")
+      # IO.readlines(dump_filename).join.split(";\n").each do |statement|
+      #   ActiveRecord::Base.connection.execute(statement)
+      # end
+      nil
+    end
 
       # for pre_loaded_fixtures, only require the classes once. huge speed improvement
       @@required_fixture_classes = false
diff --git a/activerecord/lib/active_record/railties/databases.rake b/activerecord/lib/active_record/railties/databases.rake
index 2042734..5ea5b55 100644
--- a/activerecord/lib/active_record/railties/databases.rake
+++ b/activerecord/lib/active_record/railties/databases.rake
@@ -282,16 +282,17 @@ db_namespace = namespace :db do
   end
 
   namespace :structure do
-    desc 'Dump the database structure to db/structure.sql. Specify another file with DB_STRUCTURE=db/my_structure.sql'
+    desc 'Dump the database structure to db/schema.sql. Specify another file with DB_STRUCTURE=db/my_structure.sql'
     task :dump => [:environment, :load_config] do
-      filename = ENV['DB_STRUCTURE'] || File.join(ActiveRecord::Tasks::DatabaseTasks.db_dir, "structure.sql")
+      # Invoca Patch - change 'structure.sql' to 'schema.sql'
+      filename = ENV['DB_STRUCTURE'] || File.join(ActiveRecord::Tasks::DatabaseTasks.db_dir, "schema.sql")
       current_config = ActiveRecord::Tasks::DatabaseTasks.current_config
       ActiveRecord::Tasks::DatabaseTasks.structure_dump(current_config, filename)
 
       if ActiveRecord::Base.connection.supports_migrations? &&
           ActiveRecord::SchemaMigration.table_exists?
         File.open(filename, "a") do |f|
-          f.puts ActiveRecord::Base.connection.dump_schema_information
+          f.puts ActiveRecord::Base.connection.dump_schema_information.gsub(/AUTO_INCREMENT=\d+ /,'') # Invoca Patch - need this for the custom data type patch in the abstract_mysql_adapter
         end
       end
       db_namespace['structure:dump'].reenable
@@ -299,9 +300,16 @@ db_namespace = namespace :db do
 
     # desc "Recreate the databases from the structure.sql file"
     task :load => [:environment, :load_config] do
-      filename = ENV['DB_STRUCTURE'] || File.join(ActiveRecord::Tasks::DatabaseTasks.db_dir, "structure.sql")
+      # Invoca Patch - change 'structure.sql' to 'schema.sql'
+      filename = ENV['DB_STRUCTURE'] || File.join(ActiveRecord::Tasks::DatabaseTasks.db_dir, "schema.sql")
       current_config = ActiveRecord::Tasks::DatabaseTasks.current_config
-      ActiveRecord::Tasks::DatabaseTasks.structure_load(current_config, filename)
+      # Invoca Patch - check that file exists and load file
+      File.exists?(filename) or abort %{#{filename} doesn't exist yet. Run "rake db:migrate" to create it then try again. If you do not intend to use a database, you should instead alter #{Rails.root}/config/boot.rb to limit the frameworks that will be loaded}
+      command = "mysql '-u#{config["username"]}' '-p#{config["password"]}' '#{config["database"]}' < '#{filename}'"
+      puts command if ENV['verbose'] != 'false'
+      system( command )
+      $?.success? or raise "#{task.name} failed executing `#{command}`"
+      # ActiveRecord::Tasks::DatabaseTasks.structure_load(current_config, filename)
     end
 
     task :load_if_sql => ['db:create', :environment] do
